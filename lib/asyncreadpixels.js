// from
// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices

function clientWaitAsync(gl, sync, flags, interval_ms) {
    return new Promise((resolve, reject) => {
      function test() {
        const res = gl.clientWaitSync(sync, flags, 0);
        if (res === gl.WAIT_FAILED) {
          reject();
          return;
        }
        if (res === gl.TIMEOUT_EXPIRED) {
          setTimeout(test, interval_ms);
          return;
        }
        resolve();
      }
      test();
    });
  }
  
  async function getBufferSubDataAsync(
    gl,
    target,
    buffer,
    srcByteOffset,
    dstBuffer,
    /* optional */ dstOffset = 0,
    /* optional */ length = 0,
  ) {
    const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
    gl.flush();
  
    await clientWaitAsync(gl, sync, 0, 10);
    gl.deleteSync(sync);
  
    gl.bindBuffer(target, buffer);
    gl.getBufferSubData(target, srcByteOffset, dstBuffer, dstOffset, length);
    gl.bindBuffer(target, null);
  
    return dstBuffer;
  }
  
  export async function readPixelsAsync(gl, x, y, w, h, format, type, dest) {
    const buf = gl.createBuffer();
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
    gl.bufferData(gl.PIXEL_PACK_BUFFER, dest.byteLength, gl.STREAM_READ);
    gl.readPixels(x, y, w, h, format, type, 0);
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
  
    await getBufferSubDataAsync(gl, gl.PIXEL_PACK_BUFFER, buf, 0, dest);
  
    gl.deleteBuffer(buf);
    return dest;
  }